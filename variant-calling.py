#!/usr/bin/env python3
##!/usr/bin/python3

'''
Sample Pegasus workflow for Automating a Variant Calling Workflow
Based on Lesson Data Wrangling and Processing for Genomics from
the Data Carpentry Workshop
https://datacarpentry.org/wrangling-genomics/05-automation/index.html
'''

import argparse
import logging
import os
import shutil
import sys

from Pegasus.api import *

logging.basicConfig(level=logging.DEBUG)
BASE_DIR = os.path.abspath(os.path.dirname(__file__))

# need to know where Pegasus is installed for notifications
PEGASUS_HOME = shutil.which('pegasus-version')
PEGASUS_HOME = os.path.dirname(os.path.dirname(PEGASUS_HOME))

def generate_wf():
    '''
    Main function that parses arguments and generates the pegasus
    workflow
    '''

    parser = argparse.ArgumentParser(description="generate a pegasus workflow")
    parser.add_argument('--sequence-reads-list', dest='sequence_reads_list', default=None, required=True,
                        help='Specifies list of samples from which reads are aligned')
    parser.add_argument('--reference-genome', dest='reference_genome', default=None, required=True,
                        help='Specifies the reference genome file')
    # temp argument
    parser.add_argument('--fastq-dir', dest='fastq_dir', default=None, required=True,
                        help='Directory where input fastq files are')
    args = parser.parse_args(sys.argv[1:])
    
    wf = Workflow('variant-calling')
    tc = TransformationCatalog()
    rc = ReplicaCatalog()
    
    # --- Properties ----------------------------------------------------------
    
    # set the concurrency limit for the download jobs, and send some extra usage
    # data to the Pegasus developers
    props = Properties()
    props['pegasus.catalog.workflow.amqp.url'] = 'amqp://friend:donatedata@msgs.pegasus.isi.edu:5672/prod/workflows'
    props.write() 
    
    # --- Event Hooks ---------------------------------------------------------

    # get emails on all events at the workflow level
    wf.add_shell_hook(EventType.ALL, '{}/share/pegasus/notification/email'.format(PEGASUS_HOME))
    
    # --- Transformations -----------------------------------------------------
    
    container = Container(
                   'variant-calling',
                   Container.DOCKER,
                   'docker://pegasus/variant-calling:latest'
                )
    tc.add_containers(container)

    bwa = Transformation(
                       'bwa',
                       site='incontainer',
                       container=container,
                       pfn='/opt/software/install/bwa/default/bwa',
                       is_stageable=False
                    )
    bwa.add_profiles(Namespace.CONDOR, key='request_memory', value='1 GB')
    tc.add_transformations(bwa)

    """
    samtools = Transformation(
        'samtools',
        site='incontainer',
        container=container,
        pfn='/opt/software/install/samtools/default/bin/samtools',
        is_stageable=False
    )
    samtools.add_profiles(Namespace.CONDOR, key='request_memory', value='1 GB')
    tc.add_transformations(samtools)
    """

    # we use the simple bash wrapper to convert to bam,
    # sort and index the generated bam file
    samtools = Transformation(
        'samtools',
        site='local',
        container=container,
        pfn=BASE_DIR + '/tools/samtools_wrapper',
        is_stageable=True
    )
    samtools.add_profiles(Namespace.CONDOR, key='request_memory', value='2 GB')
    tc.add_transformations(samtools)

    bcftools = Transformation(
        'bcftools',
        site='incontainer',
        container=container,
        pfn='/opt/software/install/bcftools/default/bin/bcftools',
        is_stageable=False
    )
    bcftools.add_profiles(Namespace.CONDOR, key='request_memory', value='1 GB')
    tc.add_transformations(bcftools)

    vcfutils = Transformation(
        'vcfutils',
        site='incontainer',
        container=container,
        pfn='/opt/software/install/bcftools/default/bin/vcfutils.pl',
        is_stageable=False
    )
    vcfutils.add_profiles(Namespace.CONDOR, key='request_memory', value='1 GB')
    tc.add_transformations(vcfutils)


    # --- Workflow -----------------------------------------------------
    # set up the reference genome and what files need to be generated by the index job
    ref_genome = File('ecoli_rel606.fasta')
    rc.add_replica('local', 'ecoli_rel606.fasta', os.path.abspath(args.reference_genome))
    index_files = []
    for suffix in ['amb', 'ann', 'bwt', 'pac', 'sa']:
        index_files.append(File(ref_genome.lfn + "." + suffix))

    # index the reference file
    index_job = Job('bwa')
    index_job.add_args('index', ref_genome.lfn)
    index_job.add_inputs(ref_genome)
    index_job.add_outputs(*index_files, stage_out=False)
    wf.add_jobs(index_job)

    # create jobs for each trimmed fastq trim.sub.fastq
    fh = open(args.sequence_reads_list)
    for line in fh:
        sra_id = line.strip()
        if len(sra_id) < 5:
            continue

        # files for this id
        fastq_1 = File('{}_1.trim.sub.fastq'.format(sra_id))
        fastq_2 = File('{}_2.trim.sub.fastq'.format(sra_id))
        rc.add_replica('local', fastq_1, os.path.join(os.path.abspath(args.fastq_dir), fastq_1.lfn))
        rc.add_replica('local', fastq_2, os.path.join(os.path.abspath(args.fastq_dir), fastq_2.lfn))

        sam=File('{}.aligned.sam'.format(sra_id))
        bam=File('{}.aligned.bam'.format(sra_id))
        sorted_bam=File('{}.aligned.sorted.bam'.format(sra_id))

        raw_bcf=File('{}_raw.bcf'.format(sra_id))
        variants=File('{}_variants.bcf'.format(sra_id))
        final_variants=File('{}_final_variants.bcf'.format(sra_id))

        """
        bwa mem $genome $fq1 $fq2 > $sam
    samtools view -S -b $sam > $bam
    samtools sort -o $sorted_bam $bam 
    samtools index $sorted_bam
    bcftools mpileup -O b -o $raw_bcf -f $genome $sorted_bam
    bcftools call --ploidy 1 -m -v -o $variants $raw_bcf 
    vcfutils.pl varFilter $variants > $final_variants
    """

        # align reads job
        j = Job('bwa')
        j.add_args('mem', ref_genome, fastq_1, fastq_2)
        j.add_inputs(*index_files, ref_genome, fastq_1, fastq_2)
        j.set_stdout(sam, stage_out=False)
        wf.add_jobs(j)

        # samtools_wrapper for doing alignment to genome
        j = Job('samtools')
        j.add_args(sra_id)
        j.add_inputs(sam)
        j.add_outputs(bam, sorted_bam, stage_out=False)
        wf.add_jobs(j)

        # Variant calling
        # bcftools for calculating the read coverage of positions in the genome
        j = Job('bcftools')
        j.add_args('mpileup -O b -o', raw_bcf, '-f', ref_genome, sorted_bam)
        j.add_inputs(ref_genome, sorted_bam)
        j.add_outputs(raw_bcf, stage_out=False)
        wf.add_jobs(j)

        # bcftools for Detect the single nucleotide variants (SNVs)
        j = Job('bcftools')
        j.add_args('--ploidy 1 -m -v -o', variants, raw_bcf)
        j.add_inputs(raw_bcf)
        j.add_outputs(variants, stage_out=False)
        wf.add_jobs(j)

        # vcfutils Filter and report the SNV variants in variant calling format (VCF)
        j = Job('vcfutils')
        j.add_args('varFilter', variants, '>', final_variants)
        j.add_inputs(variants)
        j.add_outputs(final_variants, stage_out=True)
        wf.add_jobs(j)

    try:
        wf.add_transformation_catalog(tc)
        wf.add_replica_catalog(rc)
        wf.plan(verbose=3, submit=True)
    except PegasusClientError as e:
        print(e.output)


if __name__ == '__main__':
    generate_wf()

